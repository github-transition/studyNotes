# JS性能优化

## 垃圾回收机制

![垃圾回收](.\img\s16573704162025.png)

```typescript
    let a = { name: 'zjh' } // 这里的 { name: 'zjh' } 就会被回收
    a = [1,2,3,4];

```

> 我们知道写代码时创建一个基本类型、对象、函数......都是需要占用内存的，但是我们并不关注这些，因为这是引擎为我们分配的，我们不需要显示手动的去分配内存，那么JS引擎是如何发现并清理垃圾的呢？

### 可达性

```javascript
let obj = { x: 1 };
obj = null; // obj 的引用被移除,这就是不可达
```

#### 引用计数算法

- 当声明了一个变量并且将一个引用类型值赋值给该变量的时候这个值的引用次数就为 1
- 如果这个变量又被赋给另一个变量，那么引用数加 1
- 如果这个变量的值被其他的值覆盖，则引用次数减 1
- 当这个值的引用次数为0的时候，说明没有变量再使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为0的值占用的内容

```javascript
let person = { name: 'zjh' }  // { name: 'zjh' } 的引用次数为 1
// 第一行：let person = { name: 'zjh' }
//     创建了一个对象 { name: 'zjh' }。
//     变量 person 指向这个对象。
//     引用计数：对象 { name: 'zjh' } 的引用计数为 1（被 person 引用）。
let son = person // son 被赋值为 person, 他们都指向同一个对象 此时引用次数为 2
// 第二行：let son = person
//     创建了一个新的变量 son。
//     son 被赋值为 person，即 son 和 person 都指向同一个对象 { name: 'zjh' }。
//     引用计数：对象 { name: 'zjh' } 的引用计数增加为 2（被 person 和 son 共同引用）。
person = [1,2,3] // { name: 'zjh' } 的引用计数减少为 1 （仅被 son 引用）
// 第三行：person = [1,2,3]
//     创建了一个新的数组 [1,2,3]。
//     变量 person 被重新赋值为这个数组。
//     原来的对象 { name: 'zjh' } 仍然被 son 引用，但不再被 person 引用。
//     引用计数：
//     对象 { name: 'zjh' } 的引用计数减少为 1（仅被 son 引用）。
//     数组 [1,2,3] 的引用计数为 1（被 person 引用）。
// 最终状态
//     对象 { name: 'zjh' } 的引用计数为 1（被 son 引用）。
//     数组 [1,2,3] 的引用计数为 1（被 person 引用）。
// 如果后续代码中没有任何对 { name: 'zjh' } 的引用，那么它的引用计数将变为零，最终会被垃圾回收器回收。

```

![测试](.\img\s17143704162025.png)

这个算法最怕的就是循环应用，还有不恰当的闭包

例子：

```javascript
function test() {
    let A = new Object()
    let B = new Object()

    A.b = B
    B.a = A
}
```

当函数 test 执行完毕后，变量 A 和 B 的作用域结束，它们的引用会被移除。此时：
A 的引用计数减少为 1（仅被 B.a 引用）。
B 的引用计数减少为 1（仅被 A.b 引用）。
由于 A 和 B 互相引用，它们的引用计数永远不会为零，因此引用计数算法无法回收它们，即使它们已经不再被外部代码使用。

**优点**

引用计数算法的优点我们对比标记清楚来看就会清晰很多，只要被引用就+1+1+1，引用数为0的那一刻，就是变成垃圾被回收，所以他可以立即回收垃圾
而标记清楚算法需要每隔一段时间进行一次，那在应用程序（JS脚本）运行过程中线程就必须要暂停去执行一段时间的 `GC`，另外标记清除法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了。

**缺点**

引用计数的缺点，首先他需要一个计数器，计数器需要占很大的位置，因为我们也不知道被引用数量的上限，还有就是无法解决循环引用无法回收的问题，这也是最严重的

#### 标记清除（mark-sweep）算法

标记清除（mark-sweep），目前在 `JavaScript引擎` 里这种算法是最常用的，目前为止的大多数浏览器的 `JavaScript引擎` 都在采用标记清除算法，各大浏览器厂商都对此算法进行了优化加工，而且不同的浏览器 `JavaScript引擎` 频率也不一样

标记清除只有 0 和 1，他只关注进来了，出没出去，不关注次数

它分为 `标记` 和 `清除` 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）摧毁

![过程](.\img\s17461304162025.png)

整个标记清除算法大致过程就像下面这样

1. 垃圾收集器在运行时会给内存中的所有变量打上一个标记，假设内存中所有的对象都是垃圾，全部标记为0
2. 然后从各个根节点对象开始遍历，把不是垃圾的节点改成1
3. 清除所有标记为0的垃圾，销毁并回收他们所占用的内存空间
4. 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收

**优点**

标记清除算法优点是很简单，实现比较简单

**缺点**

清除后剩余内存空间是不变的，会导致内存空间不连续，导致出现 `内存碎片`，他最大的问题就是会产生内存碎片导致内存不连续
就好比 [1,2,3]  2 被清除了 变成了 [1, ,3] 不连续了, 这种情况导致这块内存没有被利用起来
一旦不连续了就会产生内存碎片，我们想让他按着按着存储

#### 标记整理清除法

标记整理清除法是进阶版，标记和整理它不仅内存清除还进行收纳

他会在标记后清除的时候，把这块空间放在一个位置先放着，然后把内存移到正确位置，收纳

![标记整理清除法](.\img\s20311304162025.png)

## 内存管理

V8 将堆内存分为 新生代(1-8M)和老生代 两区域

频繁变动的内容我们暂时归为新生代

经过多个轮回一段时间的我们把他们归为老生代

### 新生代

![新生代又分为两个小类别](.\img\s20442104162025.png)

空闲区和使用区域

空闲区我们可以吧新内容放到空闲区中，空闲区慢慢被写满，这里面有些内容会被转为老生代中，然后有些内容我们发现没有用了，我们会在新生代中，把他处理掉压根不会进入老生代中。

当我们空闲的空间占用了25%，就会进入老生代中，25%是为了避免影响后续内存分配

### 老生代

不同于新生代，老生代中存储的内容是相对使用频繁并且短时间内无需回收的内容，这部分我们使用**标记清除**进行处理
